a1k[b-1,k]
searchIntT <- c(-2,2)
k
i
k <- 1
i <- 1
rootik	<- uniroot(function(x) dlpthe(x, X1[i,k], X2[i,k], a1k[1,k], a2k[1,k], sig2k[1,k], link), interval = searchIntT)
rootik
round(rootik$root, 3)
round(c(-0.1, 0.1) + rootik$root, 3)
tseq	<- seq(-0.2, 0.01, by = 0.005)#
lT		<- vector('numeric', length = length(tseq))#
dlT		<- vector('numeric', length = length(tseq))#
#
for(i in 1:length(tseq)){#
	lT[i]	<- lpthe(tseq[i], X1[i,k], X2[i,k], a1k[1,k], a2k[1,k], sig2k[1,k], link)#
	dlT[i]	<- dlpthe(tseq[i], X1[i,k], X2[i,k], a1k[1,k], a2k[1,k], sig2k[1,k], link)#
}
cbind(tseq, lT, dlT, exp(dlT))
curve(dlpthe(x, X1[i,k], X2[i,k], a1k[1,k], a2k[1,k], sig2k[1,k], link), from = -1, to = 1)
curve(dlpthe(x, X1[i,k], X2[i,k], a1k[1,k], a2k[1,k], sig2k[1,k], link), from = -0.2, to = 0.01)
tseq	<- seq(-0.2, 0.01, by = 0.005)#
lT		<- vector('numeric', length = length(tseq))#
dlT		<- vector('numeric', length = length(tseq))#
#
for(i in 1:length(tseq)){#
	lT[i]	<- lpthe(tseq[i], X1[1,k], X2[1,k], a1k[1,k], a2k[1,k], sig2k[1,k], link)#
	dlT[i]	<- dlpthe(tseq[i], X1[1,k], X2[1,k], a1k[1,k], a2k[1,k], sig2k[1,k], link)#
}
cbind(tseq, lT, dlT, exp(dlT))
sdth
getStart(X1, X2, 2)
n21/n12
temp <- getStart(X1, X2, 2)
temp$n21/temp$n12
log(temp$n21/temp$n12)
round(c(-0.1, 0.1) + rootik$root, 3)
g
d
YFtheta
if(is.null(searchIntA)){#
		if(link == 'probit'){#
			searchIntA	<- c(-8,8)#
		} else if(link == 'cloglog'){#
			searchIntA	<- c(-13, 3)#
		} else {#
			searchIntA	<- c(-10, 10)#
		}#
	}
link		<- 'logit' # 'logit', 'probit', 'cloglog'#
B		<- 10#
burn		<- 10#
up 		<- 5#
#
ak			<- rep(0.1, ncol(X1))#
bk			<- rep(0.1, ncol(X1))#
S1			<- diag(ncol(X1))#
S2			<- diag(ncol(X1))#
v1			<- ncol(X1) - 1#
v2			<- ncol(X1) - 1#
yfTheta		<- c(-1,1)#
autoEnvA		<- TRUE#
searchInt	<- NULL#
e			<- 1#
d			<- 0.1#
yfAlpha1		<- NULL#
yfAlpha2		<- NULL#
ymin			<- -Inf#
ymax			<- Inf
if(is.null(searchIntA)){#
		if(link == 'probit'){#
			searchIntA	<- c(-8,8)#
		} else if(link == 'cloglog'){#
			searchIntA	<- c(-13, 3)#
		} else {#
			searchIntA	<- c(-10, 10)#
		}#
	}
link		<- 'logit' # 'logit', 'probit', 'cloglog'#
B		<- 10#
burn		<- 10#
up 		<- 5#
#
ak			<- rep(0.1, ncol(X1))#
bk			<- rep(0.1, ncol(X1))#
S1			<- diag(ncol(X1))#
S2			<- diag(ncol(X1))#
v1			<- ncol(X1) - 1#
v2			<- ncol(X1) - 1#
autoEnvT		<- TRUE#
searchIntT	<- NULL#
d			<- 0.1#
autoEnvA		<- TRUE#
searchIntA	<- NULL#
e			<- 1#
yfAlpha1		<- NULL#
yfAlpha2		<- NULL#
ymin			<- -Inf#
ymax			<- Inf
if(is.null(searchIntA)){#
		if(link == 'probit'){#
			searchIntA	<- c(-8,8)#
		} else if(link == 'cloglog'){#
			searchIntA	<- c(-13, 3)#
		} else {#
			searchIntA	<- c(-10, 10)#
		}#
	}
K		<- ncol(X1)	# number of outcomes#
	n		<- nrow(X1)	# number of pairs#
	a1k		<- matrix(0, nrow = burn+B, ncol = K)#
	a2k		<- matrix(0, nrow = burn+B, ncol = K)#
	E1		<- array(0, dim = c(K, K, burn+B))#
	E2		<- array(0, dim = c(K, K, burn+B))#
	R1		<- matrix(0, nrow = burn+B, ncol = K*(K-1)/2)#
	R2		<- matrix(0, nrow = burn+B, ncol = K*(K-1)/2)#
	sig2k	<- matrix(0, nrow = burn+B, ncol = K)#
	theik	<- array(0, dim = c(n, K, burn+B))#
#
	YFtheta		<- rep(list(rep(list(yfTheta), K)), n)#
	YFalpha1	<- rep(list(yfAlpha1), K)#
	YFalpha2	<- rep(list(yfAlpha2), K)#
	a1k[1,]		<- rep(0, K)#
	a2k[1,]		<- rep(0, K)#
	E1[,,1]		<- diag(K)#
	E2[,,1]		<- diag(K)#
	sig2k[1,]	<- rep(0.1, K)#
#
	ar1			<- matrix(0, nrow = burn+B, ncol = K)#
	ar2			<- matrix(0, nrow = burn+B, ncol = K)#
	art			<- array(0, dim = c(n, K, burn+B))
if(autoEnvT){#
		for(k in 1:K){#
			for(i in 1:n){#
				rootik	<- uniroot(function(x) dlpthe(x, X1[i,k], X2[i,k], a1k[1,k], a2k[1,k], sig2k[1,k], link), interval = searchIntT)#
				YFtheta[[i]][[k]]	<- round(c(-d, d) + rootik$root, 3)#
			}#
		}#
	} else {#
		if(is.null(yfTheta)){#
			stop('User must provide starting envelope or set autoEnvT to TRUE')			#
		}#
	}
searchIntT
link		<- 'logit' # 'logit', 'probit', 'cloglog'#
B		<- 10#
burn		<- 10#
up 		<- 5#
#
ak			<- rep(0.1, ncol(X1))#
bk			<- rep(0.1, ncol(X1))#
S1			<- diag(ncol(X1))#
S2			<- diag(ncol(X1))#
v1			<- ncol(X1) - 1#
v2			<- ncol(X1) - 1#
autoEnvT		<- TRUE#
searchIntT	<- c(-2,2)#
d			<- 0.1#
autoEnvA		<- TRUE#
searchIntA	<- NULL#
e			<- 1#
yfAlpha1		<- NULL#
yfAlpha2		<- NULL#
ymin			<- -Inf#
ymax			<- Inf
if(is.null(searchIntA)){#
		if(link == 'probit'){#
			searchIntA	<- c(-8,8)#
		} else if(link == 'cloglog'){#
			searchIntA	<- c(-13, 3)#
		} else {#
			searchIntA	<- c(-10, 10)#
		}#
	}
K		<- ncol(X1)	# number of outcomes#
	n		<- nrow(X1)	# number of pairs#
	a1k		<- matrix(0, nrow = burn+B, ncol = K)#
	a2k		<- matrix(0, nrow = burn+B, ncol = K)#
	E1		<- array(0, dim = c(K, K, burn+B))#
	E2		<- array(0, dim = c(K, K, burn+B))#
	R1		<- matrix(0, nrow = burn+B, ncol = K*(K-1)/2)#
	R2		<- matrix(0, nrow = burn+B, ncol = K*(K-1)/2)#
	sig2k	<- matrix(0, nrow = burn+B, ncol = K)#
	theik	<- array(0, dim = c(n, K, burn+B))#
#
	YFtheta		<- rep(list(rep(list(yfTheta), K)), n)#
	YFalpha1	<- rep(list(yfAlpha1), K)#
	YFalpha2	<- rep(list(yfAlpha2), K)#
	a1k[1,]		<- rep(0, K)#
	a2k[1,]		<- rep(0, K)#
	E1[,,1]		<- diag(K)#
	E2[,,1]		<- diag(K)#
	sig2k[1,]	<- rep(0.1, K)#
#
	ar1			<- matrix(0, nrow = burn+B, ncol = K)#
	ar2			<- matrix(0, nrow = burn+B, ncol = K)#
	art			<- array(0, dim = c(n, K, burn+B))
if(autoEnvT){#
		for(k in 1:K){#
			for(i in 1:n){#
				rootik	<- uniroot(function(x) dlpthe(x, X1[i,k], X2[i,k], a1k[1,k], a2k[1,k], sig2k[1,k], link), interval = searchIntT)#
				YFtheta[[i]][[k]]	<- round(c(-d, d) + rootik$root, 3)#
			}#
		}#
	} else {#
		if(is.null(yfTheta)){#
			stop('User must provide starting envelope or set autoEnvT to TRUE')			#
		}#
	}
YFtheta
if(autoEnvA){#
		a1Roots	<- vector('numeric', length = K)#
		a2Roots	<- vector('numeric', length = K)#
		for(k in 1:K){#
			root1k <- uniroot(function(x) dlpalp(x, a1k[1,], k, theik[,k,1], X1[,k], E1[,,1], link), interval = searchIntA)#
			root2k	<- uniroot(function(x) dlpalp(x, a2k[1,], k, theik[,k,1], X2[,k], E2[,,1], link), interval = searchIntA)#
			a1Roots[k]	<- root1k$root#
			a2Roots[k]	<- root2k$root#
#
			YFalpha1[[k]]	<- round(c(-e,e) + root1k$root, 1)#
			YFalpha2[[k]]	<- round(c(-e,e) + root2k$root, 1)			#
		}				#
	} else {#
		if(is.null(yfAlpha1)){#
			stop('User must provide starting envelope or set autoEnvA to TRUE')#
		}#
#
		if(is.null(yfAlpha2)){#
			stop('User must provide starting envelope or set autoEnvA to TRUE')#
		}#
	}
upFix	<- TRUE
for(b in 2:(burn+B)){#
		# Sample \Sigma_j ##
		E1[,,b]	<- SigmajUpdate(a1k[b-1,], S1, v1, K)#
		E2[,,b]	<- SigmajUpdate(a2k[b-1,], S2, v2, K)#
		R1b		<- cov2cor(E1[,,b])#
		R2b		<- cov2cor(E2[,,b])#
		R1[b,]	<- extractr(R1b, K)#
		R2[b,]	<- extractr(R2b, K)#
		# Sample \sigma_k^2 ##
		sig2k[b,]	<- apply(theik[,,b-1], 2, sigma2Update, samp.size = 1, n = n, ak = ak, bk = bk)#
		# loop over outcomes ##
		for(k in 1:K){#
			# sample \theta_ik ##
			for(i in 1:n){#
				yfixik	<- YFtheta[[i]][[k]]#
				thUpik	<- thetaUpdate(1, yfixik, X1[i,k], X2[i,k], a1k[b-1,k], a2k[b-1,k], sig2k[b-1,k], link, ymin, ymax, upFix)#
				theik[i,k,b]			<- thUpik$thetab#
				if(upFix){#
					YFtheta[[i]][[k]]	<- thUpik$yfixedb#
				} else {#
					art[i,k,b]			<- thUpik$count#
				}#
			}#
#
			# \alpha_1k#
			yfixa1k	<- YFalpha1[[k]]#
			a1Upk	<- alphaUpdate(1, yfixa1k, a1k[b-1,], k, theik[,k,b-1], X1[,k], E1[,,b-1], link, ymin, ymax, upFix)#
			a1k[b,k]				<- a1Upk$alphab#
			if(upFix){#
				YFalpha1[[k]]	<- a1Upk$yfixedb#
			} else {#
				ar1[b,k]		<- a1Upk$count#
			}#
			# \alpha_2k#
			yfixa2k	<- YFalpha2[[k]]#
			a2Upk	<- alphaUpdate(1, yfixa2k, a2k[b-1,], k, theik[,k,b-1], X2[,k], E2[,,b-1], link, ymin, ymax, upFix)#
			a2k[b,k]				<- a2Upk$alphab#
			if(upFix){#
				YFalpha2[[k]]	<- a2Upk$yfixedb#
			} else {#
				ar2[b,k]		<- a2Upk$count				#
			}#
		}#
		if(b == burn){#
			cat("tuning stage complete, beginning sampling\n")#
			upFix	<- FALSE#
		}#
		if(b > burn){#
			if(mod(b, up) == 0){#
				cat(paste(b - burn,"samples completed\n"))#
			}#
		}#
	}
b
k
i
thUpik	<- thetaUpdate(1, yfixik, X1[i,k], X2[i,k], a1k[b-1,k], a2k[b-1,k], sig2k[b-1,k], link, ymin, ymax, upFix)
yfixik
samp.size	<- 1#
yfixed		<- yfixik#
x1			<- X1[i,k]#
x2			<- X2[i,k]#
a1			<- a1k[b-1,k]#
a2			<- a2k[b-1,k]#
s			<- sig2k[b-1,k]
lpthe(yfixed[1], x1, x2, a1, a2, s, link)
lpthe(yfixed[2], x1, x2, a1, a2, s, link)
lpthe(yfixed[3], x1, x2, a1, a2, s, link)
dlpthe(yfixed[3], x1, x2, a1, a2, s, link)
exp(dlpthe(yfixed[3], x1, x2, a1, a2, s, link))
exp(lpthe(yfixed[3], x1, x2, a1, a2, s, link))
exp(1111)
exp(710)
exp(709)
exp(500)
exp(-500)
exp(100)
exp(-5.4)
dlpthe(yfixed[1], x1, x2, a1, a2, s, link)
dlpthe(yfixed[2], x1, x2, a1, a2, s, link)
thresh
uthe(yfixed[1], yfixed, x1, x2, a1, a2, s, link, ymin, ymax)
uthe(yfixed[2], yfixed, x1, x2, a1, a2, s, link, ymin, ymax)
uthe(yfixed[3], yfixed, x1, x2, a1, a2, s, link, ymin, ymax)
lpthe(yfixed[3], x1, x2, a1, a2, s, link)
lpthe(yfixed[3], x1, x2, a1, a2, s, link) - uthe(yfixed[3], yfixed, x1, x2, a1, a2, s, link, ymin, ymax)
exp(0)
yfixed
sthe.sample(samp.size, yfixed, x1, x2, a1, a2, s, link, ymin)
sthe.sample(samp.size, c(-0.1, 0.1), x1, x2, a1, a2, s, link, ymin)
Ys <- 0.006740847
U	<- runif(1)
test <- U < exp(lpthe(Ys, x1, x2, a1, a2, s, link) - uthe(Ys, yfixed, x1, x2, a1, a2, s, link, ymin, ymax))
test
curve(lpthe(x, x1, x2, a1, a2, s, link), from = -5, to = 5)
curve(dlpthe(x, x1, x2, a1, a2, s, link), from = -5, to = 5)
curve(exp(lpthe(x, x1, x2, a1, a2, s, link)), from = -5, to = 5)
curve(exp(lpthe(x, x1, x2, a1, a2, s, link)), from = -2, to = 2)
curve(exp(lpthe(x, x1, x2, a1, a2, s, link)), from = -1, to = 1)
dlpthe(-1, x1, x2, a1, a2, s, link)
dlpthe(1, x1, x2, a1, a2, s, link)
dlpthe(-0.5, x1, x2, a1, a2, s, link)
dlpthe(0.5, x1, x2, a1, a2, s, link)
exp(dlpthe(0.5, x1, x2, a1, a2, s, link))
exp(dlpthe(-0.5, x1, x2, a1, a2, s, link))
a1
a2
k
yp
exp(lpthe(yp, x1, x2, a1, a2, s, link))/dlpthe(yp, x1, x2, a1, a2, s, link) * ( exp((zp - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) - exp((zm - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) )
yfixed
yp <- 1
exp(lpthe(yp, x1, x2, a1, a2, s, link))/dlpthe(yp, x1, x2, a1, a2, s, link) * ( exp((zp - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) - exp((zm - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) )
yp <- 0.1
exp(lpthe(yp, x1, x2, a1, a2, s, link))/dlpthe(yp, x1, x2, a1, a2, s, link) * ( exp((zp - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) - exp((zm - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) )
yp <- 0.01
exp(lpthe(yp, x1, x2, a1, a2, s, link))/dlpthe(yp, x1, x2, a1, a2, s, link) * ( exp((zp - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) - exp((zm - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) )
exp(lpthe(yp, x1, x2, a1, a2, s, link))
dlpthe(yp, x1, x2, a1, a2, s, link)
zp
(zp - yp)
(zp - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)
exp((zp - yp)*dlpthe(yp, x1, x2, a1, a2, s, link))
zm
(zm - yp)
zfixed
yfixik
yfixed
Ys	<- sthe.sample(samp.size, yfixed, x1, x2, a1, a2, s, link, ymin)
zfixed			<- zfthe(yfixed, x1, x2, a1, a2, s, link)
zfixed
gp				<- sthe(zfixed, yfixed, x1, x2, a1, a2, s, link)
gp
vals <- zfixed
zfixed		<- zfthe(yfixed, x1, x2, a1, a2, s, link)
zfixed
zlen 		<- length(zfixed)
zlen
pct 			<- numeric(length(vals))
pct
norm.const	<- 0
zi <- 0
if(zi == 0){#
			zm	<- -Inf#
		} else {#
			zm	<- zfixed[zi]#
		}
if(zi == zlen){#
			zp	<- Inf#
		} else {#
			zp	<- zfixed[zi+1]#
		}
zm
zp
yp			<- yfixed[zi+1]
yp
ds			<- exp(lpthe(yp, x1, x2, a1, a2, s, link))/dlpthe(yp, x1, x2, a1, a2, s, link) * ( exp((zp - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) - exp((zm - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) )
ds
cidx		<- zm < vals & vals <= zp
cidx
hidx		<- vals > zp
hidx
pct[cidx]	<- pct[cidx] + exp(lpthe(yp, x1, x2, a1, a2, s, link))/dlpthe(yp, x1, x2, a1, a2, s, link) * ( exp((vals[cidx] - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) - exp((zm - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) )
pct
pct[hidx]	<- pct[hidx] + ds
pct
norm.const <- norm.const + ds
norm.const
zlen
zi <- 1
if(zi == 0){#
			zm	<- -Inf#
		} else {#
			zm	<- zfixed[zi]#
		}
zm
if(zi == zlen){#
			zp	<- Inf#
		} else {#
			zp	<- zfixed[zi+1]#
		}
zp
yp			<- yfixed[zi+1]
yp
ds			<- exp(lpthe(yp, x1, x2, a1, a2, s, link))/dlpthe(yp, x1, x2, a1, a2, s, link) * ( exp((zp - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) - exp((zm - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) )
ds
cidx		<- zm < vals & vals <= zp
hidx		<- vals > zp
pct[cidx]	<- pct[cidx] + exp(lpthe(yp, x1, x2, a1, a2, s, link))/dlpthe(yp, x1, x2, a1, a2, s, link) * ( exp((vals[cidx] - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) - exp((zm - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) )
pct[hidx]	<- pct[hidx] + ds
norm.const <- norm.const + ds
pct
norm.const
zi <- 2
zlen
if(zi == 0){#
			zm	<- -Inf#
		} else {#
			zm	<- zfixed[zi]#
		}
zm
if(zi == zlen){#
			zp	<- Inf#
		} else {#
			zp	<- zfixed[zi+1]#
		}
zp
yp			<- yfixed[zi+1]
yp
ds			<- exp(lpthe(yp, x1, x2, a1, a2, s, link))/dlpthe(yp, x1, x2, a1, a2, s, link) * ( exp((zp - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) - exp((zm - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) )
ds
yp <- 2
ds			<- exp(lpthe(yp, x1, x2, a1, a2, s, link))/dlpthe(yp, x1, x2, a1, a2, s, link) * ( exp((zp - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) - exp((zm - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) )
ds
yp <- 1
ds			<- exp(lpthe(yp, x1, x2, a1, a2, s, link))/dlpthe(yp, x1, x2, a1, a2, s, link) * ( exp((zp - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) - exp((zm - yp)*dlpthe(yp, x1, x2, a1, a2, s, link)) )
ds
dlpthe(Ys, x1, x2, a1, a2, s, link)
dlpthe(1, x1, x2, a1, a2, s, link)
bound
Ys <- 2.395814
bound <- 1
tbound <- 1
dlpEval		<- dlpthe(Ys, x1, x2, a1, a2, s, link)
dlpEval
dlpThresh	<- dlpthe(tbound, x1, x2, a1, a2, s, link)
dlpThresh
abs(dlpEval)
abs(thresh)
abs(dlpThresh)
abs(dlpEval) < abs(dlpThresh)
addFix		<- abs(dlpEval) < abs(dlpThresh)
upFix
addFix
addFix & upFix
abound
exp(500)
exp(500)*exp(500)
exp(400)*exp(400)
exp(300)*exp(300)
0.002/Inf
Inf/Inf
Inf-Inf
Inf - exp(300)*exp(300)
Inf - exp(400)*exp(300)
Inf - exp(400)*exp(400)
exp(100)
exp(200)
source('/Users/mjm556/Dropbox/Research/Drafts/Matched Proportions/Code/bmmaps6.R')
1/Inf
1 + 1/Inf
1
1 + 1/Inf
system.time(1 + 1/Inf)
1e100
1e400
1/1e400
1/1e300
1/1e350
1/1e500
0-1/1e500
pvSpec	<- list(a_lambda = 0.001,#
			a_gamma = 0.001,#
			b_gamma = 0.001,#
			a_omega = 0.001,#
			a_eta = 0.001,#
			b_eta = 0.001,#
			tol = 1e-5,#
			maxIter = 10)
attach(pvSpec)
ls()
unlist(pcSpec)
unlist(pvSpec)
exp(100)
?integrate
source('/Users/mjm556/Dropbox/Research/Drafts/Matched Proportions/Code/bmmaps10.R')
setwd('/Users/mjm556/Dropbox/Research/Drafts/Matched Proportions/Artificial Settings/K2SM')
X1ash	<- readRDS('X1ash.RData')#
X2ash	<- readRDS('X2ash.RData')
size(X1ash)
dim(X1ash)
dim(X2ash)
source('~/Documents/Code/BMMaPs/bmmaps.R')
setwd('~/Documents/Code/BMMaPs/Data')
X1ash	<- readRDS('X1ash.RData')
X2ash	<- readRDS('X2ash.RData')
d	<- 1			# change to 2 or 3 to vary level of discordancy
X1	<- X1ash[,,d]	# matrix of outcomes for first treatment
X2	<- X2ash[,,d]	# matrix of outcomes for second treatment
pvSpec	<- list(lambda = 300, omega = 100,#
				tTune = 0.04, nuTau = 5^2,#
				sTune = c(0.0015, 0.002), nuSig = 3^2)
modelHC	<- bmmps(X1, X2, link = 'logit', B = B, burn = burnin, up = 100, priorVar = "HC",#
				pvSpec = pvSpec)
modelHC	<- bmmaps(X1, X2, link = 'logit', B = 100, burn = 1000, up = 100, priorVar = "HC",#
				pvSpec = pvSpec)
modelHC	<- bmmaps(X1, X2, link = 'logit', B = 100, burn = 100, up = 100, priorVar = "HC",#
				pvSpec = pvSpec)
B		<- 100	# 1000#
burnin	<- 100
pvSpec	<- list(a_lambda = 0.001, a_gamma = 0.001, b_gamma = 0.001,#
				a_omega = 0.001, a_eta = 0.001, b_eta = 0.001,#
				tol = 1e-10, maxIter = 10)
B		<- 100	# 1000#
burnin	<- 100
modelVB	<- bmmaps(X1, X2, link = 'logit', B = B, burn = burnin, up = 100, priorVar = "VB",#
				pvSpec = pvSpec)
summary(modelHC)
summary(modelVB)
